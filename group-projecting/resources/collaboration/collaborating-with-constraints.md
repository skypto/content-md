# Constriant-Based Problem Solving

One of the most important skills you can learn to become a 10x developer is to write exactly and only the simplest code necessary to.  This skill is much harder to learn and much more rare than being able to write cool applications.
This lesson is a shot at teaching you this skill.


### Index
* [constraints](#constraints)   
* [analysis first](#analysis-first)
* [decomposition](#decomposition)
* [common constraints](#common-constriants)  
* [collaboration process](#collaboration-process)  
* [studying like this](#studying-with-constraints) 
* [resources](#resources)
___
## Constraints

Constraints force you to commit to one path and follow it through.  They force you to think creatively in order to work around them.  They force you to focus your energies onto a smaller set of possible solutions. Adding constraints improves and accelerates creative problem solving.

It may sound intuitively wrong, but the fewer restrictions you have on your work the more difficult it is to be creative.  One of the crucial skills you need to learn is when and how to place restrictions on yourself.  

Specs are a perfect example of self-imposed constraints that help enormously in producing a final product.  Without the structure of agreed-upon specs you would have to spend much more of your time remembering what you're doing and how it fits with the last piece you built.  

On the group level, specs are indispensible.  Without agreeing on specs before beginning to code, it's almost guarenteed that your team's code will not work when you piece it together.  By constraining yourselves to a set of specs, you are free as a group to take more liberties in implementation and workflow with the confidence that your project will work when everyone has finished their piece.

[TOP](#index)
___
## Analysis First

When presented with a new problem, it is a waste of time to start by trying to solve it.  The moment you begin thinking of solutions, you limit your energies to debating or improving the proposed solutions rather than looking for new perspectives on the problem.

Before even considering solutions, you should spend more time than you want to conidering the problem from every angle. This is also not intuitive, but a crucial skill to understand and practice.

As a developer, you are very rarely solving a problem that has been exactly solved before (or you'd be using someone else's code).  You will rarely have much guidance.  You will often have have a lot of freedom in coming up with your solution.  This is not the best situation for creative problem solving.

You must manage your time and your patience to maximize your efforts.  By spending extra time understading the problem then even more selecting the correct constraints for yourself, you will be saving yourself and your team time in the future.

> “Given one hour to save the world, I would spend 55 minutes defining the problem and 5 minutes finding the solution.” ~ Albert Einstein

[TOP](#index)
___
## Common Constraints

This list is long and it's not even near comprehensive.  Rather than looking it as an enormous list of shutdowns, try thinking of it as a bunch of decisions you don't have to make.  Free yourself!



Some common constraints when developing software:
* The audiences:
  * A user must understand your applicaiton.
  * Developers must understand your code.
  * Computers must run your code.
* Other people
  * Bad legacy code
  * Unpleasant team-mates
  * Bad junior developers
  * Even worse senior developers
  * Bad managers
  * Impossible customers
* Yourself
  * Skill/experience limitations
  * Tool familiarity
  * Bad work habits
  * Bad attitude
  * Poor team-working skills
* Development
  * Deadlines
  * Budgets
  * Specs
  * Unexpected changes in any of these
  * Architecture 
* Technology stacks:
  * Programming languages
  * Frameworks 
  * Lack of frameworks
  * Compatibility
* Hardware, yours and users:
  * Speed
  * Price
  * OS
* And so so many more ...

[TOP](#index)
___
## Decomposition

Problem decomposition is central to problem solving.  Being able to look at a large problem and understand it as many small problems strung together will make you a better human.  

Some of many advantages:      
* You have created helpful constraints.  Two smaller problems are easier to approach and will usually result in a higher quality finished product.  
* Collaboration becomes easier. You can split work with the guarentee that each person's contribution will be valuable.  
* It can guide the analysis phase.  Often the hardest question is how to start understanding a problem. by first decomposing a new problem, you can skip being confused by how to start.  Decomposing is always worth your time.  
* Smaller pieces are easier to code.  Decomposing large problems brings them closer to code, making the trasition to a practical solution much simpler.  
* Apps built of smaller apps are almost always easier to test and maintain.  
  
I'm sure there are more benefits to breaking down large problems, but these should be enough to convince you.  

Getting good at this will just take practice.    
  
  
[TOP](#index)
___
## Collaboration Process

A procedure worth trying out:
1. Analyze and define the task as a team
2. Break the problem into smaller pieces  
3. Analyze and define the smaller problems as a team
    * Agree on specs where smaller problems meet eachother or the outside world
4. Delegate the smaller problems to pieces of your team
5. Create stand-alone solutions to each smaller problem. (micro-services)
6. Assemble the smaller solutions in a first draft of the final product
7. Assess, discuss, refactor.
    

[TOP](#index)
___
## Resources

Constraints:
* [from medium, david](https://medium.com/stanford-d-school/want-some-creativity-crank-up-the-constraints-5728a988a635)
* [creative constraints](https://ed.ted.com/lessons/the-power-of-creative-constraints-brandon-rodriguez)
* [From photography](http://erickimphotography.com/blog/2015/08/06/the-beauty-of-creative-constraints-in-photography/)
* [types of constraints](https://www.psychologytoday.com/blog/beautiful-minds/201108/does-creativity-require-constraints)
* [wired, to sciency?](https://www.wired.com/2011/11/need-to-create-get-a-constraint/)
* [forbes](https://www.forbes.com/sites/groupthink/2013/07/12/creativity-how-constraints-drive-genius/#3aab55e33d89)

Analysis First:
* [Problem vs. Solution Oriented Thinking](http://www.planetofsuccess.com/blog/2011/problem-vs-solution-focused-thinking/)
* [rockefeller](https://www.rockefellerfoundation.org/blog/defining-problem-find-solution/)
* [analysis paralysis](https://en.wikipedia.org/wiki/Analysis_paralysis)
* [A3](http://www.heitmanagement.com/blog/2013/08/a3-thinking-understand-problems-before-trying-to-solve-them/)
* [managing to learn](https://www.lean.org/events/mtl_foreword_intro_chapt_1and2.pdf)
* [triz](https://en.wikipedia.org/wiki/TRIZ)
* [lesswrong](http://lesswrong.com/lw/ka/hold_off_on_proposing_solutions/)

Problem Decomposition:
* [BBC decomposition](https://www.bbc.co.uk/education/guides/zqqfyrd/revision/3) 
* [BBC algorithms](https://www.bbc.co.uk/education/guides/zpp49j6/revision)

Articles on studying like this:
* [Makers 1](https://blog.makersacademy.com/coding-101-thinking-like-a-programmer-4fafd4a1e0f2)
* [Makers 2](http://blog.makersacademy.com/scientific-method-in-programming/)


Other:
* [1*x](http://wiki.c2.com/?DevelopersWithHighProductivityTenxHundredxThousandx)









